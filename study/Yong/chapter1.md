## 역사 
### monolith -> micro service
몇년전 소프트웨어 애플리케이션 -> monolith
#### 단점
* 릴리스 주기가 느리고 비교적 업데이트가 자주 되지 않는다
* 한 부분을 변경하더라도 전체 애플리케이션을 재배포
* 복잡성 증가, 품질 저하

최근에는 더 작은 구성 요소로 세분화 하는 마이크로서비스
#### 장점
* 개별적 개발, 배포, 업데이트 확장
* Rest api를 제공하는 http(동기 프로토콜), amqp(비동기 프로토콜)로 통신
#### 단점
* 구성요소가 많을 때 배포 관련 결정이 어려워짐 (배포조합수도 많아지고 구성요소간의 상호 종속성 수가 많음)
* 실행 호출을 디버그하고 추적하기어려움(zipkin같은 분산추적시스템으로 해결)
* 라이브러리 버전 다를수있음

### 애플리케이션에 일관된 환경 제공

### 데브옵스와 노옵스
개발자, QA, 운영팀이 협업 -> 데브옵스
운영팀을 거치지않고 개발자가 배포 -> 노옵스 (쿠버네티스)


## 컨테이너란
가상머신 -> 컨테이너 오버헤드(추가 컴퓨팅 리소스)가 훨씬 적음, 가벼움
가상머신을 사용할때 호스트os와 하이퍼바이저가 물리적 리소스를 각 가상머신에 나눠줌
컨테이너 실행은 host os에서
컨테이너는 보안 위험이 발생할 수 있음 (동일한 커널을 호출하기 때문)

컨테이너 격리가 가능한 이유 두가지
(1) 네임스페이스
동일한 네임스페이스 내에 있는 리소스만 볼수있음(독립된 뷰)
(2) 리눅스 컨트롤 그룹 cgroups
컨테이너가 사용할수 있는 리소스 양 제한

도커의 세가지 주요 개념
이미지, 레지스토리, 컨테이너

이미지 모든 환경, 라이브러리, 모든 파일 다 포함되어있음
컨테이너 이미지는 공유되고 재사용 될 수 있는 layer로 구성되어있음
레이어에서 없는 특정 레이어만 다운로드하면됨
이미지는 layer이라 공통된 부모 이미지가 있으니 동일한 바이너리, 라이브러리에 접근가능

## 쿠버네티스
컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템
쿠버가 여러 애플리케이션들을 워커노드에 배포해줌

쿠버네티스 클러스터 아키텍처
마스터노드(컨트롤 플레인)은 클러스터를 제어, 작동
워커 노드 실제 배포된 애플리케이션 실행

애플리케이션 실행 flow
컨터이너 이미지로 패킹 -> 해당 이미지를 레지스트리로 푸시 -> 디스크립션 게시

#### 장점
* 배포의 단순화
* 하드웨어 활용도 높이기 (가장 적합한 노드를 선택해줌)
* 상태확인과 자가치유
* 오토스케일링
* 애플리케이션 개발 단순화
* 신뢰성 증가 (지속적인 전달 가속화)
