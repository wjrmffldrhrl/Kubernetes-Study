# k8s 스터디 1주차
## 컨테이너의 이해
* 일반적으로 서로 다른 소프트웨어는 서로 다른 라이브러리, 버전, 환경을 필요로 한다
* 때때로 서로 충돌하기도 하며 그렇기 때문에 이들 간 격리가 필요하다


### 컨테이너 vs 가상머신
1. 컨테이너는 가볍고 가상머신은 무겁다
2. 컨테이너는 호스트 OS 위에서 실행되는 프로세스, 가상머신은 hypervisor위에서 동작하는 별도의 OS
3. 컨테이너는 호스트 OS의 커널을 사용, 가상머신은 자체 OS의 커널을 사용하여 완전한 격리
4. 컨테이너는 부팅 프로세스가 필요 없다(?)

### 컨테이너 격리 메커니즘
* 리눅스 네임 스페이스
	* 프로세스가 시스템에 대한 독립된 뷰만 접근할수 있도록 하는 기능
* 리눅스 컨트롤 그룹(cgroups)
	* 프로세스가 사용할수 있는 리소스를 제한하는 기능

파일 시스템, 프로세스ID, 사용자ID, 네트워크 인터페이스 등의 시스템 리소스는 네임스페이스에 속해있으며 프로세스를 실행할때 특정 네임스페이스를 선택하여 프로세스를 실행할 수 있다.

어떤 네임스페이스에서는 해당 네임스페이스에 속하는 리소스만 접근할 수 있으므로 논리적으로 격리된다


#### 네임스페이스 종류
1. 마운트(mnt)
2. 프로세스 ID(pid)
3. 네트워크(net)
4. 프로세스 간 통신(ipc)
5. 호스트와 도메인 이름(uts)
6. 사용자 ID(user)


## 도커 컨테이너
애플리케이션, 라이브러리, 종속성, 파일시스템등 전체 환경을 함께 패키징 가능한 컨테이너 플랫폼
리눅스 컨테이너를 이용하여 가상머신과 거의 동일한 격리수준을 제공한다
컨테이너의 이미지가 재사용가능한 layer로 구분되어있다


### 도커의 주요 개념
* 이미지
	* 애플리케이션과 환경을 패키지화 한것
	* 파일시스템, 실행 경로 등이 포함
* 레지스트리
	* 도커 이미지를 저장하고 공유할 수 있는 저장소
	* remote 저장소에 대한 push, pull 가능
* 컨테이너
	* 도커 이미지에서 생성된 리눅스 컨테이너


### 도커 이미지 레이어의 이해
* 모든 도커 이미지는 다른 이미지 위에 빌드되기 때문에 네트워크를 통한 빌드 속도가 빨라진다
* 컨테이너 이미지는 읽기 전용으로, 쓰기가 발생한 경우 전체 파일의 copy의 최상위 레이어에 쓰여진다

### 제한적 이식성
 이론적으로 컨테이너 이미지는 도커를 실행하는 모든 리눅스 시스템에서 실행될수 있지만 애플리케이션이 특정 리눅스 커널을 의존하는 경우 그럴 수 없다



## 쿠버네티스
컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템
리눅스 컨테이너를 통해 애플리케이션을 완전히 격리할 수 있고 이기종 애플리케이션을 실행할 수 있게 한다
애플리케이션을 실행하는 클러스터의 운영체제로 생각할 수 있다
이를 통해 서비스 디스커버리, 스케일링, 로드밸런싱, 자가 치유, 리더 선출등을 쿠버네티스에 의존하여 애플리케이션을 인프라위로 올리는데 시간을 낭비 하지 않아도 된다

### 클러스터 구성
* 노드
	* 마스터 노드
		* 전체 k8s 시스템을 제어하고 관리하는 컨트롤 플레인 실행
		* API 서버
			* 사용자, 컨트롤 플레인의 구성요소와 통신 
		* etcd
			* 클러스터 구성을 지속적으로 저장하는 분산 데이터 저장소
		* 스케줄러
			* 애플리케이션 배포를 담당
		* 컨트롤러 매니저
			* k8s resource의 copy, 워커 노드 추적, 장애 처리 기능 수행
	* 워커 노드
		* 실제 배포되는 컨테이너를 실행
		* Kubelet
			* 마스터 노드의 api 서버와 통신하고 노드의 컨테이너를 관리
		* kube-proxy
			* resource간 트래픽을 로드밸런싱
		* 컨테이너 런타임
			* 도커, rkt 등의 컨테이너 런타임


### k8s에서 애플리케이션 실행
1. 컨테이너 이미지 패키징
2. 이미지 레지스트리 푸시
3. K8s api서버에 애플리케이션 디스크립션 게시
	* 앱이 실행되면 k8s는 앱의 상태가 디스크립션과 일치하는지 지속적으로 확인한다



## k8s 사용의 장점
* 컨테이너화 된 앱은 모든것이 포함되어 있으므로 다른 설치과정이 필요 없다
* 모든 워커 노드에 대해 하나의 배포 플랫폼으로 제공되므로 클러스터에 대해 알 필요 없이 배포를 할 수 있다(?)
* 인프라와 앱을 분리하여 하드웨어 활용도 상승
	* 앱의 노드간 이동이 자유로워 하드웨어 리소스를 효율적으로 사용할 수 있다
* 앱 구성요소와 노드를 모니터하여 상태를 유지하므로 시스템의 자가 치유가 가능하다
* 앱의 리소스를 모니터링하여 자동으로 scale-out 처리 할 수 있다
* CICD 신뢰성 증가
